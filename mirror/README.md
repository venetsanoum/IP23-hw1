- Για την επίλυση της άσκησης 2:
    * Φτιάχνω μια συνάρτηση **prime** με την οποία ελέγχεται αν ένας αριθμός είναι πρώτος. Για οικονομία χρόνου ελέγχω πρώτα τη περίπτωση ένας αριθμός να είναι πολλαπλάσιο του 2 ή 3 μιας και τότε δεν θα είναι σίγουρα πρώτος αριθμός. Εν συνεχεία φτιάχνω ένα for loop το οποίο εφόσον βρίσκει οτι ο εκάστοτε αριθμός διαιρείται με κάποιον άλλον αριθμό πέρα του 1 και του ίδιου του αριθμού επιστρέφει 1 (δηλαδή ο αροθμός δεν είναι πρώτος). Το for αυξάνεται με βήμα 6 αφου έχουν αποκλειστεί τα πολλαπλάσια του 2 και του 3.
        - Όταν διαιρώ έναν αριθμό με το 2 (ο οποίος δεν ειναι πολλαπλάσιο του 2) το αποτέλεσμα είναι **είτε 1 είτε -1** 
        - Όταν διαιρώ έναν αριθμό με το 3 (ο οποίος δεν ειναι πολλαπλάσιο του 3) το αποτέλεσμα είναι **1, 2, 4 ή 5**
            - Επομένως οι αριθμοί που μένουν είναι της μορφης **6κ + 1** ή **6κ - 1** ή **6κ + 5** ή **6κ - 5** για κάποιο ακέραιο κ.
            Άρα οι πιθανοί πρώτοι αριθμοί είναι της μορφής **6κ + 1** ή **6κ - 1** ή **6κ + 5** ή **6κ - 5**. Βέβαια μπορεί να είναι και της μορφής **6κ+ 7** ή **6κ -7** (μιας και επίσης δεν διαιρούνται με 2 ή 3). Επομένως η συνθήση ελέγχου είναι **αν το n διαιρείται με το i ή αν διαιρείται με το i + 2**  γιατι το i + 2 μπορεί να διαιρεί τους αριθμούς της μορφης **6κ + 7 ή 6κ - 7**.
            - Το loop φτάνει *μέχρι και τη ρίζα του αριθμού* n γιάτι εφόσον υπάρχει κάποιος διαιρέτης μικρότερος από ρίζα του αριθμού προφάνως και θα υπάρχει ένας αντίστοιχος μεγαλύτερος από τη ρίζα.

    * Φτιάχνω μια συνάρτηση **mirror** η οποία επιστρέφει το κάτοπτρο ένος αριθμού. Λειτουργεί ως εξής: 
        - Αρχικοποιώ το κάτοπτρο (*reversed*) σε 0.
        - Η διαδικασία επαναλαμβάνεται όσο δεν έρχουν επεξεργαστεί όλα τα ψηφία του αριθμού: 
            - Κρατάω σε μια μεταβλητή *remain* το τελευταίο ψηφίου του αριθμού.
            - Εφόσον το τελευταίο θα γίνει πρώτο ψηφίο πολλαπλασιάζω τον αριθμό *reversed* με 10 και προσθέτουμε το *remain* (εκτος απο τη πρώτη φορα που 0 * 10 = 0 τις επόμενες τα τελευταια ψηφια πολλαπλασιάζονται επί 10 ώστε να δημιουργηθεί το κάτοπτρο του αριθμού.)
            - Ανανεώνουμε τον αριθμό n διαιρώντας τον με 10 και αφαιρώντας με αυτον τον τρόπο το τελευταίο ψηφίο το οποίο χρησιμοποιήθηκε.
    * Φτιάχνω μια συνάρτηση **FindRequiredRoot**  η οποία:
        - Αρχικά υπολογίζει τη τετραγωνική ρίζα ενος αριθμού με δεκαδικά ψηφία (χρήση *(long double)* πριν τη sqrt()).
        - Εφόσον δεν είναι πρώτος αριθμός η ρίζα η συνάρτηση επιστρέφει 0, αλλιως επσιτρέφεται ο αριθμός.

    * Στη συνάρτηση **main**: 
        - Μετατρέπονται τα ορίσματα σε long long ακεραίους.
        - Ελέγχονται οι εκτός ορίων περιπτώσεις.
        - Αρχικοποιείται η μεταβλητή *sum* στην οποία θα προσθεθούν τα κατοπτρικά πρώτα τετράγωνα.
        - Το πρόγραμμα θα ***φτιάχνει*** τα κατοπτρικά πρώτα τετράγωνα και **δεν** θα τα αναζητεί (για οικονομία χρόνου) επομένως το for loop θα ξεκινάει απο τη τετραγωνική ρίζα του κάτω ορίου μέχρι και τη τετραγωνική ρίζα του άνω ορίου.
        - Καλεί τη συνάρτηση **FindRequiredRoot** , τη συνάρτηση **mirror** και ξανά τη **FindRequiredRoot** 
        - Eπειτα ελέγχεται αν το τετράγωνο του κατοπτρικού αριθμού του i είναι τέλειο τετράγωνο με τη χρήση της floor() , η οποία βρίσκει το μεγαλύτερο ακέραιο που δεν υπερβαίνει τον i.
        - Eφόσον η ρίζα του αριθμού και του κατοπτρικού αριθμού είναι πρώτοι αριθμοί και ο αριθμός δεν ειναι παλλινδρομικός προσθέτουμε τoν αριθμό που έχει επιστραφεί απο τις συναρτήσεις (ο οποίος είναι το τετράγωνο του εκάστοτε αριθμού i) στο *sum*. 
        